<html>
  <head>
    <title>Juice=Juice判定器</title>
    <script src="https://cdn.jsdelivr.net/npm/vue"></script>
    <script type="text/javascript" src="./face-api.min.js"></script>
    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@1.1.2"></script>
  </head>
  <body>
    <div id="app">
      <canvas id="mainCanvas"></canvas>
      <div class="labels" v-for="pred in predictions" v-if="predictions.length > 0">
        <div>
          <p>{{ pred[0] }}: {{ pred[1] }}%</p>
        </div>
      </div>
    </div>
    <script>
      const app = new Vue({
        el: '#app',
        data: {
          predictions: [],
        },
        mounted: function() {
          const vm = this
          const label = [
            "akariuemura",
            "karinmiyamoto",
            "manakainaba",
            "rurudanbara",
            "sayukitakagi",
            "tomokokanazawa",
            "yukamiyazaki"
          ]

          tf.loadLayersModel('./model.json').then(model => {
            console.log("Loaded!")
            setupCanvas('./sample.jpg', 64, 64).then((resp) => {
              resp.context.putImageData(resp.imgData, 0, 0);
              const imgData = toGrayScale(resp.imgData, resp.width, resp.height)
              let tfObj = tf.browser.fromPixels(imgData)
              tfObj = tfObj.reshape([1, 64, 64, 3])
              tf.tidy(() => {
                const prediction = model.predict(tfObj)
                let results = []
                tf.softmax(prediction).data().then((scores) => {
                  for (let i = 0; i < scores.length; i++) {
                    results.push([member_to_name(label[i]), (scores[i] * 100).toFixed(2)])
                  }
                  results = results.sort((a, b) => {
                    return b[1] - a[1]
                  })
                  vm.predictions = results
                })
              })
            })
          });
        }
      });

      async function faceDetect(canvas) {
        await faceapi.nets.ssdMobilenetv1.load('/')
        const options = new faceapi.SsdMobilenetv1Options({ minConfidence: 0.5 })
        const detections = await faceapi.detectSingleFace(canvas, options)
        return detections
      }

      function setupCanvas(imgUrl, resizeW, resizeH) {
        const canvas = document.querySelector('#mainCanvas');
        if (!canvas) return null;
        const context = canvas.getContext("2d");
        if (!context) return null;
        return new Promise((resolve, reject) => {
          const img = new Image();
          img.crossOrigin = "Anonymous";
          img.src = imgUrl;
          img.onload = async () => {
            context.clearRect(0, 0, img.width, img.height);
            const detections = await faceDetect(img)
            canvas.width = resizeW;
            canvas.height = resizeH;
            context.drawImage(img, detections.box.x, detections.box.y, detections.box.width, detections.box.height, 0, 0, resizeW, resizeH);
            const imgData = context.getImageData(0, 0, canvas.width, canvas.height);
            resolve({
              canvas: canvas,
              context: context,
              imgData: imgData,
              pixels: imgData.data,
              width: canvas.width,
              height: canvas.height
            });
          };
          img.onerror = () => reject(null);
        });
      }

      function toGrayScale(imgData, imgWidth, imgHeight) {
        for (let y = 0; y < imgHeight; y++) {
          for (let x = 0; x < imgHeight; x++) {
            const idx = (y * imgWidth + x) * 4;
            const medColor =
              (Math.max(imgData.data[idx + 0], imgData.data[idx + 1], imgData.data[idx + 2]) +
                Math.min(imgData.data[idx + 0], imgData.data[idx + 1], imgData.data[idx + 2])) /
              2;
            imgData.data[idx] = medColor;
            imgData.data[idx + 1] = medColor;
            imgData.data[idx + 2] = medColor;
            imgData.data[idx + 3] = 255;
          }
        }
        return imgData;
      }

      function member_to_name(member) {
        if (member == "akariuemura") {
          return "植村あかり"
        } else if (member == "karinmiyamoto") {
          return "宮本佳林"
        } else if (member == "manakainaba") {
          return "稲場愛香"
        } else if (member == "rurudanbara") {
          return "段原瑠々"
        } else if (member == "sayukitakagi") {
          return "高木紗友希"
        } else if (member == "tomokokanazawa") {
          return "金澤朋子"
        } else if (member == "yukamiyazaki") {
          return "宮崎由加"
        }
      }
    </script>
  </body>
</html>