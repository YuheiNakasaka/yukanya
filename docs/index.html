<html>
  <head>
    <title>Juice=Juice判定器</title>
    <script src="https://cdn.jsdelivr.net/npm/vue"></script>
    <script type="text/javascript" src="./face-api.min.js"></script>
    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@1.1.2"></script>
    <style>
      #container {
        width: 320px;
        margin: 60px auto 0 auto;
      }
      #previewCanvas {
        max-width: 250px;
        max-height: 250px;
      }
      .canvases {
        text-align: center;
      }
      p.label-name.first {
        font-weight: bold;
      }
      .detail {
        text-align: center;
      }
      .loading {
        text-align: center;
      }
    </style>
  </head>
  <body>
    <div id="app">
      <div id="container">
        <div class="main">
          <div class="canvases">
            <canvas id="mainCanvas"></canvas>
            <canvas id="previewCanvas"></canvas>
          </div>

          <div class="detail" v-if="loading === false">
            <div class="labels">
              <div v-for="(pred, index) in predictions">
                <p class="label-name" :class="index === 0 ? 'first' : ''">{{ pred[0] }}: {{ pred[1] }}%</p>
              </div>
            </div>
            <div class="meta">
              <input type="file" @change="onFileChange" />
            </div>
          </div>

          <div class="loading" v-else>
            <p>読み込み中...</p>
          </div>
        </div>
      </div>
    </div>
    <script>
      const app = new Vue({
        el: '#app',
        data: {
          predictions: [],
          loading: true,
        },
        mounted: function() {
          this.predict()
        },
        methods: {
          onFileChange: function(e) {
            const vm = this
            if (e.target) {
              const files = e.target.files;
              if (!files) return;
              if (!files[0].type.match(/image.*/)) {
                alert('画像ファイルをアップロードしてください')
                return;
              }
              const reader = new FileReader();
              reader.onload = async () => {
                if (!reader.result || reader.result instanceof ArrayBuffer) return;
                vm.predict(reader.result)
              };
              reader.readAsDataURL(files[0]);
            }
          },
          predict: function(imageFile = './sample.jpg') {
            const vm = this
            const label = [
              "akariuemura",
              "karinmiyamoto",
              "manakainaba",
              "rurudanbara",
              "sayukitakagi",
              "tomokokanazawa",
              "yukamiyazaki"
            ]
            vm.loading = true
            tf.loadLayersModel('./model.json').then(model => {
              console.log("Loaded!")
              setupCanvas(imageFile, 64, 64).then((resp) => {
                if (resp !== false) {
                  const imgData = toGrayScale(resp.imgData, resp.width, resp.height)
                  let tfObj = tf.browser.fromPixels(imgData)
                  tfObj = tfObj.reshape([1, 64, 64, 3])
                  tf.tidy(() => {
                    const prediction = model.predict(tfObj)
                    let results = []
                    tf.softmax(prediction).data().then((scores) => {
                      for (let i = 0; i < scores.length; i++) {
                        results.push([member_to_name(label[i]), (scores[i] * 100).toFixed(2)])
                      }
                      results = results.sort((a, b) => {
                        return b[1] - a[1]
                      })
                      vm.predictions = results
                      vm.loading = false
                    })
                  })
                } else {
                  alert("顔が検出できませんでした");
                  vm.predictions = [];
                  vm.loading = false
                }
              })
            }).catch((e) => {
              alert("モデルの読み込みに失敗しました。通信環境の良いところで試してください。")
            });
          }
        }
      });

      async function faceDetect(canvas) {
        await faceapi.nets.ssdMobilenetv1.load('/')
        const options = new faceapi.SsdMobilenetv1Options({ minConfidence: 0.5 })
        const detections = await faceapi.detectSingleFace(canvas, options) 
        return detections
      }

      function setupCanvas(imgUrl, resizeW, resizeH) {
        const canvas = document.querySelector('#mainCanvas');
        const prevCanvas = document.querySelector('#previewCanvas');
        if (!canvas) return null;
        const context = canvas.getContext("2d");
        const prevContext = prevCanvas.getContext("2d");
        if (!context) return null;
        return new Promise((resolve, reject) => {
          const img = new Image();
          img.crossOrigin = "Anonymous";
          img.src = imgUrl;
          img.onload = async () => {
            context.clearRect(0, 0, canvas.width, canvas.height);
            prevContext.clearRect(0, 0, prevCanvas.width, prevCanvas.height);
            const detections = await faceDetect(img)
            if (!detections) {
              resolve(false)
            } else {
              canvas.width = resizeW;
              canvas.height = resizeH;
              prevCanvas.width = img.width;
              prevCanvas.height = img.height;
              prevContext.drawImage(img, 0, 0, img.width, img.height, 0, 0, img.width, img.height)
              context.drawImage(img, detections.box.x, detections.box.y, detections.box.width, detections.box.height, 0, 0, resizeW, resizeH);
              const imgData = context.getImageData(0, 0, canvas.width, canvas.height);
              resolve({
                canvas: canvas,
                context: context,
                imgData: imgData,
                pixels: imgData.data,
                width: canvas.width,
                height: canvas.height
              });
            }
          };
          img.onerror = () => reject(null);
        });
      }

      function toGrayScale(imgData, imgWidth, imgHeight) {
        for (let y = 0; y < imgHeight; y++) {
          for (let x = 0; x < imgHeight; x++) {
            const idx = (y * imgWidth + x) * 4;
            const medColor =
              (Math.max(imgData.data[idx + 0], imgData.data[idx + 1], imgData.data[idx + 2]) +
                Math.min(imgData.data[idx + 0], imgData.data[idx + 1], imgData.data[idx + 2])) /
              2;
            imgData.data[idx] = medColor;
            imgData.data[idx + 1] = medColor;
            imgData.data[idx + 2] = medColor;
            imgData.data[idx + 3] = 255;
          }
        }
        return imgData;
      }

      function member_to_name(member) {
        if (member == "akariuemura") {
          return "植村あかり"
        } else if (member == "karinmiyamoto") {
          return "宮本佳林"
        } else if (member == "manakainaba") {
          return "稲場愛香"
        } else if (member == "rurudanbara") {
          return "段原瑠々"
        } else if (member == "sayukitakagi") {
          return "高木紗友希"
        } else if (member == "tomokokanazawa") {
          return "金澤朋子"
        } else if (member == "yukamiyazaki") {
          return "宮崎由加"
        }
      }
    </script>
  </body>
</html>